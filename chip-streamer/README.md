    author: boris posavec
        

# What is this project?

This is the repo for the sz20 emulator (and hopefully real hardware!). Emulator? Well, since sz2 hw is delayed, i started working on an emulator environment, that would cover basic functionality for the upcoming product. At some point we decided to use gstreamer for the realtime video feed from the device. I double-checked that both iOS and Android have supporting framework for that. gstreamer1 seems to be a lot better than gstreamer-0.1 which was used in Jasmine (MYS02) back in the days.


This project is about setting up CHIP to stream video test signal over the network to a recipient (another gstreamer listening on a specific port).
It covers how to prepare CHIP for gstreamer as well as how to develop python script for that, and on recipient' side how to enable video player for the incoming signal.


But that's not everything. It also prototypes image sequence scan and download, firmware update over internet, systemd interactions, logging mechanics, HTTP(s) server prototyping and more.
 

# How to read this manual?

This documentation, sadly, tries to encompass both system setup and application development. Some segments are only meant for firmware developers, that is how to setup software on the emulating device. Some segments are important for application developers because they explain how to communicate with the emulator, which commands are supported by it, what is the response format, etc.


# CHIP, RPI or ... ?

Initially I started this emulator with CHIP in mind, because I knew that CHIP had both stable wifi and ble, plus a decent, very fast(!) booting linux distribution with apt, systemd, wifi tools etc.

But with trivial modifications (or even none) you can use it with RPI or MacOS or Linux desktops. The only thing you need are python2.7+gstreamer-1.0.


# Instructions for Firmware developers

At the time of writing this manual there was no real sz20 hardware available. The entire ecosystem described in this manual is developed in a form of emulator hardware/software. The endpoints such as peripherals for imaging, wifi, ble etc. are all either emulated or completely omitted. Here is the detailed list of all subsystems that were successfully emulated:

* Camera : using gstreamer CLI
    * both video streaming over UDP and scan sequence are supported
    * video signal is generated by videotestsrc plugin


## What you need in order to set up the emulating device

CHIP already comes with python2.7.9 preinstalled, so you just need to add gstreamer1:

    apt install gstreamer-1.0 
    apt install gstreamer1.0-plugins-base
    apt install gstreamer1.0-plugins-good
    apt gstreamer1.0-plugins-bad
    apt install gstreamer1.0-plugins-ugly
    apt install python-gst-1.0


## MacOS gstreamer-1.0 DIY compile 

In case you are setting this up on an MacOS, get Cerberos.
https://github.com/GStreamer/cerbero

1. cerbero-uninstalled bootstrap
2. cerber-uninstalled package gstreamer-1.0
3. install by doubleclicking the needed .pkg files that were created in step 2
4. install gstreamer-1.0-devel-1.13.0.1-x86_64.pkg needed for headers and libs
5. edit .bash_profile, add:


    # add gstreamer to exe path 
    export PATH=$PATH:/Library/Frameworks/GStreamer.framework/Versions/1.0/bin/
    export PKG_CONFIG_PATH=/Library/Frameworks/GStreamer.framework/Versions/1.0/lib/pkgconfig/

.. and then when compiling use pkg-config --cflags --libs gstreamer-1.0

takes eternity to build, but it WORKS :)


## Building hello example

    # https://gstreamer.freedesktop.org/documentation/tutorials/basic/hello-world.html
    gcc hello-gst.c -o hello-gst `pkg-config --cflags --libs gstreamer-1.0`


## Python GST Test script - how to use

On OSX side, you want to receive the signal using gstreamer:

    gst-launch-1.0 udpsrc port=5000 caps="application/x-rtp, encoding-name=JPEG, payload=26" ! rtpjpegdepay ! jpegdec ! videoconvert ! autovideosink 

On CHIP side you just fire the script:

    python gst-test.py


## Main firmware script

Main firmware script is called server.py.  It is a HTTP(s in future) server listening to incoming requests and executing them, returning JSON response to the sender. JSON response is usually formatted like this:

    {"code": 200, "log": "Stopping stream\n"}

Where code is same as HTTP Header code, and log contains some debug info, that may or may not be present depending on server configuration. E.g. production version most probably won't include log messages, whereas developer version will be abundant in logging.

Note that the firmware script is also capable of logging data in a file. This file may then be either automatically uploaded to some remote server, or per GET request to the client.


## How to launch

Start server.py. It launches a http server listening on port 8001 (by default, but you can change the port in the config.py file). You may use curl to send get requests to server:

    curl localhost:8001/?act=hello
    

## Setting up sz20 server service

For the production you want the server.py (main firmware) to boot up together with the system. The OS is systemd based, so you need to do a couple of things here, manually. Just follow these steps:

* Copy the service file

   
    # copy the sz20-server.service file to /etc/systemd/system/
    cp sz20-server.service /etc/systemd/system/
    

* Link additional python module(s) to python import path 


    ln -s /path-to-sz20-firmware/python-aux/cli.py /usr/lib/python2.7/cli.py
    

* Create configuration from template


    cd path-to-sz20-firmware
    cp config.py.template config.py
    nano config.py
    
Here is the sample config provided with the emulator that runs on CHIP:

    #!/usr/bin/env python
    
    '''
    Server configuration
    server.py includes this file in order to determin various things such as gstreamer exe, port to use for bringing up HTTPS server, debug and logging options, etc.
    
    
    '''
    
    cfg = { # in case you want to use gst-launch binary this is the cmd line for streaming
            'stream_cmd' : 'gst-launch-1.0 videotestsrc ! jpegenc ! rtpjpegpay ! udpsink host="#host" port=5000',
            # single snapshot cli command
            'capture_cmd': 'gst-launch-1.0 videotestsrc num-buffers=1 ! video/x-raw,width=#width,height=#height ! jpegenc ! filesink location="#path"',
            # Set this to False if you want to use python embedded version of gst (gi), 
            # else gst-launch will be invoked as subprocess
            'use_cmd' : True,
            # where to store captured images (in case you are using server as systemd service, use absolute path here
            'image_store_path': '/root/projects/cyberscope3/chip-streamer/images/',
            # Server listenes at this port
            'port' : 8001,
            # Still TBD, but we will most probably support HTTPS
            'https' : False,
            'end' : True
            }
    
The most important options are _image_store_path_ which has to be absolute, because server.py runs as a service (relative paths won't work in that case). And _capture_cmd_ and _stream_cmd_. Make sure gstreamer is properly installed, and in executable look up path of the system, in which case you don't need absolute path to be provided for the gst-launch-1.0.
    
    
   
    
   

# Instructions for Application / Client developers

* First start the emulator. Make sure it is configured so that it can connect to your SSID / home / office network. This can be done by following the examples in the following section. 
* Once the emulator is running, you may address it by either browser or curl, your choice. See below, the section on Shell examples.
* Quickstart, type the following in shell:

    
    curl "chip.local:8001/?act=hello"


You will get a "Hello World :) " response back to notify you that the emulator is up and running. See the section on responses below. _act_ is the request command that you send to emulator. The list of all available requests is provided in the following section.


## Commands Supported by the Emulator

* *hello* - simply hails back, with code 200, use to see if server is up 
* *listssids* - lists all visible SSIDs, returns them in json log field.
* *listconnections* - lists all known wifi connections, that are already remembered by device, and that the wifi handler will try to resort to
* *play&host=receiverip[default:localhost]&port=receiverport[default:5000]* - starts video stream of resolution set by _setresolution_ action 
* *stop* - stops video stream
* *setresolution&res=640x400* - set resolution to a x b, note that depending on imaging device, there might be some resolution constraints, ie: 2560x1920 or 640x480 or 1024x720 or similar. Yet to be determined and documented.
* *scan?filename=filename* - acquires a single image, filename string, which is the name of the file on disk (or non volatile memory)
* *scanseq?filename=filename* - acquires a sequence of images, with the base filename string, which is the name of the file on disk (or non volatile memory) plus the extension, defined by the sequence configuration in the firmware
* *getimage?filename=filename* - download the image by its filename from disk (see scan command)
* *getimageseq?filename=filename* - download the zip with images (see scanseq command). The file is a .zip pack containing all the images defined by the scan sequence configuration on the device.


## Special note on _scanseq_ and _getimageseq_ requests

Each time you request a scan sequence, sz20/emulator creates a sequence of images. This sequence is defined by a special scan configuration within the firmware. For example, if you request:


    curl "chip.local:8001/?act=scanseq&filename=basename"
    curl -O -L -J "localhost:8001?act=getimageseq&filename=z"    

will create a file with name basename.zip that will contain N images in it. The number and properties of images will depend on the scan sequence configuration stored on the device.      


## Response 

The response from the emulator is in most cases a JSON string. Only in case of requesting an image (see below) the response will be the binary data, respectively encoded.

JSON response is usually formatted like this:

    {"code": 200, "log": "Stopping stream\n"}

where _code_ is same as HTTP Header code, and log contains some debug info, that may or may not be present depending on server configuration. E.g. production version most probably won't include log messages, whereas developer version will be abundant in logging. The _log_ is there only as an aid to the client side developer.


## Sync and Async requests

When doing single scans, LED and camera configuration, hello, and other similar one time requests, you should wait until you get repsponse from the sz20/emulator. The response with it's error code that you must evaluate before proceeding with the next action guarantees that the request has been executed. 

Exception is the _play_ request, that starts an async video stream, that will run on and on on the device until _stop_ is requested.

Note that any scan / scanseq request fired while video streaming is active will implicitly terminate the video stream and execute the scan procedure. Changes to resolution won't affect the running video stream. 


## Compatibility notes

Commands such as addssid, listssids and listconnections are tightly coupled with the underlying OS. E.g. on CHIP linux is configured to use _nmcli_ tool to set up and control SSIDs. On RPI it's probably _iw_. On SZ2 it's going to be .... still don't know, but some wpa-supplicant like command set. Current application does not support anything other than CHIP's _nmcli_   


## Shell / Curl based communication examples

First, make sure server.py (sz2 firmware) is running on the emulator, e.g. NTC CHIP with hostname _chip.local_ connected to the same SSID the computer you are using.

Let's hail sz2 emulator:

    curl chip.local:8001?act=hello
    {"code": 200, "log": "Hello World :) !\n"}    

Lets run a video stream, and receive it with gstreamer command line tool:

    # run a listener first
    gst-launch-1.0 udpsrc port=5000 caps="application/x-rtp, encoding-name=JPEG, payload=26" ! rtpjpegdepay ! jpegdec ! videoconvert ! autovideosink 
    
    # in a new terminal tab, tell emulator to start streaming:
    curl chip.local:8001?act=play
    
    # after that you can stop emulator stream 
    curl chip.local:8001?act=stop
    
*Attention: make sure you always stop a video stream before doing anything that affects camera resolution, or other settings (yet TBD).*

To set a resolution, call this before starting video stream.

    # set VGA resolution
    curl "chip.local:8001?act=setresolution=640x400"
    curl chip.local:8001?act=play
    # .. after a while
    curl chip.local:8001?act=stop
    
Once you set resolution, until you reboot the emulator, the resolution will be used for image acquisition, be it stream or snapshot.

Next, you want to acquire a set of images (the so called _Scan Session_):
    
    # set HD resolution
    curl "chip.local:8001?act=setresolution=2560x1920"
    curl "chip.local:8001?act=scan&filename=white.jpg"
    # todo: configure next LED
    curl "chip.local:8001?act=scan&filename=uv.jpg"
    # todo: configure next LED
    curl "chip.local:8001?act=scan&filename=green.jpg"
    

Finally, you want to download the image. Current implementation is pretty much HTTP standard approach, the image data is uploaded as Content image/jpeg (note: future implementations may support different file types, such as PNG or RAW).

    # Request file from emulator:
    curl "chip.local:8001?act=getimage&filename=white.jpg"
    
To see the image you can use any browser, and type this in the URL bar:

    chip.local:8001?act=getimage&filename=white.jpg

    
In order to capture a full image sequence, _scanseq_ command is provided:

    # Run through different LED / Camera settings and acquire a set of images, called scan sequence
    curl "chip.local:8001?act=scanseq&filename=base-file-name-for-the-set"
    # Download the zip archive containing all the images from the sequence in a single pack
    curl "chip.local:8001?act=getimageseq&filename=base-file-name-for-the-set"
    