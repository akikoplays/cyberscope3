<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>CEOPunishment, October 2017</title>
    <script src="//cdn.jsdelivr.net/phaser/2.6.2/phaser.min.js"></script>

    <style type="text/css">
        body {
            margin: 0;
            background: rgb(0,0,0);
        }
    </style>
</head>
<body>

<script type="text/javascript">

const MUSIC_ON = false;
const START_WITH = 'go';
const speed = 3.5;
var game = new Phaser.Game(800, 600, Phaser.AUTO, 'game');

var fragmentSrc = [

        "precision mediump float;",

        "varying vec2 vTextureCoord;",
        "uniform sampler2D uSampler;",

        "void main(void) {",

            "vec4 texColor = texture2D(uSampler, vTextureCoord);",

            "if (texColor.a > 0.1) {",
                "texColor = vec4(1.0, 1.0, 1.0, 1.0);",
            "}",
     
            "gl_FragColor = texColor;",

        "}"
    ];

/* ======================== BootState ==============================*/
/*  loads starting screen, shows some blitter image fx and gives control
    to the content table of contents */

var BootState = function (game){
    this.objs = [];
    this.quest = 'go';
};

BootState.prototype = {

    init: function() {

    },


    modLoaded: function(key, data) {
        this.objs['mod'] = key;
        var buffer = new Uint8Array(data);
        return buffer;
    },

    preload: function() {
        game.load.bitmapFont('gem', 'assets/gem.png', 'assets/gem.xml');
        game.load.script('protracker', 'protracker.js');
        game.load.binary('mod', 'assets/intermediate.mod', this.modLoaded, this);
        game.load.image('171', 'assets/171.png');
        game.load.image('city1', 'assets/ingame-city1.gif');
        game.load.image('rain', 'assets/rain.png');

        //  37x45 is the size of each frame
        //  There are 18 frames in the PNG - you can leave this value blank if the frames fill up the entire PNG, but in this case there are some
        //  blank frames at the end, so we tell the loader how many to load
        // game.load.spritesheet('bitch-walk', 'assets/bitch/sor3-bitch.png', 46, 90, 4);
        // game.load.spritesheet('trisha-dance', 'assets/trisha/trisha-dance.png', 57, 103, 9);

        game.load.atlas('bitch', 'assets/bitch/sprites.png', 'assets/bitch/sprites.js', Phaser.Loader.TEXTURE_ATLAS_JSON_HASH);
        game.load.atlas('trisha', 'assets/trisha/sprites.png', 'assets/trisha/sprites.js', Phaser.Loader.TEXTURE_ATLAS_JSON_HASH);

        this.filter = new Phaser.Filter(game, null, fragmentSrc);
    },

    create: function() {

        game.stage.backgroundColor = "#0000a0";
        game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
        game.scale.pageAlignHorizontally = true;
        game.scale.pageAlignVertically = true;

        game.stage.smoothed = false;
        
        this.objs['module'] = new Protracker();
        that = this;
        this.objs['module'].onReady = function() {
            if (MUSIC_ON) that.objs['module'].play();
        };
        this.objs['module'].buffer = game.cache.getBinary(this.objs['mod']);
        this.objs['module'].parse();

        // list of actors
        this.objs['actors'] = [];

        // background:
        sprite = game.add.sprite(0, 0, 'city1');
        this.objs['city1'] = sprite;

        // main character
        sprite = game.add.sprite(40, 530, 'bitch');
        sprite.animations.add('walk', Phaser.ArrayUtils.numberArray(0,3), 10, false);
        sprite.animations.add('whip', Phaser.ArrayUtils.numberArray(11,19), 10, false);
        sprite.anchor.x = 0.5;
        sprite.anchor.y = 1.0;
        sprite.scale.x = 1.5;
        sprite.scale.y = 1.5;
        sprite.filters = null;//[this.filter];
        sprite.name = 'player';
        sprite.type = 'actor';
        // this.objs['bitch'] = sprite;
        game.physics.enable(sprite, Phaser.Physics.ARCADE);
        this.objs['actors'][sprite.name] = sprite;

        // trisha character
        sprite = game.add.sprite(800, 580, 'trisha'); 
        sprite.animations.add('dance', Phaser.ArrayUtils.numberArray(0, 8), 10, true);
        sprite.animations.play('dance');
        sprite.anchor.x = 0;
        sprite.anchor.y = 1.0;
        sprite.scale.x = 1.5;
        sprite.scale.y = 1.5;
        sprite.name = 'trisha';
        sprite.type = 'actor';
        // this.objs['trisha'] = sprite;
        game.physics.enable(sprite, Phaser.Physics.ARCADE);
        this.objs['actors'][sprite.name] = sprite;

        // Make the default camera follow the ufo.
        game.world.setBounds(0,0,this.objs['city1'].width, this.objs['city1'].height);
        game.camera.follow(this.getActor('player'));

        var rect = game.add.graphics(0, 0);
        rect.beginFill(0x000000);
        rect.alpha = 1;
        rect.drawRect(400, 278, 
            50, 54);
        rect.endFill();
        this.objs["rect"] = rect;

        var rect2 = game.add.sprite(700, 280, rect.generateTexture());
        this.objs["rect2"] = rect2;        
        rect2.width = 260;
        rect2.height = 4;
        rect2.alpha = 0.4;

        // rain
        for (i=1; i<3; i++){
            this.objs['rain'+i] = game.add.sprite(0,0, 'rain');
            this.objs['rain'+i].width = game.width;
            this.objs['rain'+i].height = game.height + 100;
        }

        that = this;
        game.time.events.add(100, that.flicker, that);
        game.time.events.repeat(40, 10000000, that.rollo, that);
        game.time.events.repeat(50, 10000000, that.rain, that);
    },

   flicker: function() {
        if (this.objs['rect'].alpha == 0)
            this.objs['rect'].alpha = 1;
        else
            this.objs['rect'].alpha = 0;        
        game.time.events.add(100, this.flicker, this);
    },

    rollo: function() {
        var s = this.objs['rect2'];
        s.y++;
        if (s.y >= 304)
            s.y = 280;
    },

    rain: function() {
        this.objs['rain1'].x = Math.random() * -400;
        this.objs['rain2'].x = this.objs['rain1'].x + this.objs['rain1'].width;
    },

    collisionHandler:function (obj1, obj2) {
        game.stage.backgroundColor = '#992d2d';
        console.log('HIT');
    },

    checkHitCollision: function() {
        var actors = this.objs['actors'];

        for (var key in actors){
            var a = actors[key];
            if (a.name == "player")
                continue;
            console.log('x:' + a.x + " y:" + a.y);
            console.log('w:' + a.width + " h:" + a.height);            
        }

        // doesn't work with dictionaries, only arrays
        // for (i=0; i<actors.length; i++) {
        //     var a = actors[i];
        //     console.log('x:' + a.x + " y:" + a.y);
        //     console.log('w:' + a.width + " h:" + a.height);
        // }
    },

    getActor: function(name) {
        return this.objs['actors'][name];
    },

    update: function() {
        // Hack for passing the context of this to timeout fn
        var that = this;
        if (this.quest == 'go') {
        
            var flags = 0;
            if (game.input.keyboard.isDown(Phaser.Keyboard.LEFT))
                flags |= 1;
            if (game.input.keyboard.isDown(Phaser.Keyboard.RIGHT))
                flags |= 1 << 1;
            if (game.input.keyboard.isDown(Phaser.Keyboard.DOWN))
                flags |= 1 << 2;
            if (game.input.keyboard.isDown(Phaser.Keyboard.UP))
                flags |= 1 << 3;

            if (game.input.keyboard.isDown(Phaser.Keyboard.SPACEBAR)) {
                if (this.anim && this.anim.name != 'whip') {
                    this.getActor('player').animations.stop();
                    this.anim = this.getActor('player').animations.play('whip');
                    this.getActor('player').filters = [this.filter];
                }
            }

            if (this.anim && this.anim.name == 'whip') {
                if (!this.anim.isFinished) {
                    flags = 0;
                    this.checkHitCollision();
                }
                else {
                    this.anim = this.getActor('player').animations.play('walk');
                    this.anim.stop();
                    this.getActor('player').filters = null;
                }
            } else if (this.anim && this.anim.name == 'walk') {
                if (this.anim.isFinished)
                    this.anim.stop();
            }

            if (flags & 1) {
                if (this.getActor('player').animations.getAnimation('walk').isPlaying == false)
                            this.anim = this.getActor('player').animations.play('walk');

                this.getActor('player').x -= speed;
                if (this.getActor('player').scale.x == 1.5)
                    this.getActor('player').scale.x = -1.5
            } 
            if (flags & (1 << 1)) {
                if (this.getActor('player').animations.getAnimation('walk').isPlaying == false)
                            this.anim = this.getActor('player').animations.play('walk');
                this.getActor('player').x += speed;
                if (this.getActor('player').scale.x == -1.5)
                    this.getActor('player').scale.x = 1.5
            }
            if (flags & (1 << 2)) {
                this.getActor('player').animations.play('walk');
                this.getActor('player').y += speed;
            }
            if (flags & (1 << 3)) {
                this.anim = this.getActor('player').animations.play('walk');
                this.getActor('player').y -= speed;
            } 

            if (this.getActor('player').x < 0) 
                this.getActor('player').x = 0;
            if (this.getActor('player').x > this.objs['city1'].width - 40) 
                this.getActor('player').x = this.objs['city1'].width - 40;
            if (this.getActor('player').y < 530) this.getActor('player').y = 530;
            if (this.getActor('player').y > 600) this.getActor('player').y = 600;
        }
    },

};

game.state.add('Boot', BootState, false);
game.state.start('Boot');

</script>

</body>
</html>